<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo da Velha Neon Arcade - IA Inteligente Otimizada</title>
    <!-- Carrega Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configuração do Tailwind para Cores Neon -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'neon-blue': '#4a74ff',
                        'neon-pink': '#ff4aff',
                        'neon-bg': '#1a0d24',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Estilo customizado para o brilho neon */
        .neon-text-blue {
            text-shadow: 0 0 5px #4a74ff, 0 0 10px #4a74ff, 0 0 20px #4a74ff;
            color: #fff;
        }
        .neon-shadow-blue {
            box-shadow: 0 0 10px #4a74ff;
        }
        .neon-shadow-pink {
            box-shadow: 0 0 10px #ff4aff;
        }
        .cell-glow-x {
            color: #fff;
            text-shadow: 0 0 8px #4a74ff, 0 0 15px #4a74ff;
        }
        .cell-glow-o {
            color: #fff;
            text-shadow: 0 0 8px #ff4aff, 0 0 15px #ff4aff;
        }
    </style>
</head>
<body class="bg-neon-bg min-h-screen flex items-center justify-center p-4 font-sans text-white">

    <div id="appContainer" class="w-full max-w-lg mx-auto bg-gray-900/50 p-6 rounded-xl shadow-2xl">

        <!-- TELA DE CONFIGURAÇÃO (SETUP SCREEN) -->
        <div id="setupScreen" class="text-center">
            <h1 class="text-3xl font-extrabold mb-8 neon-text-blue">JOGO DA VELHA</h1>
            <h2 class="text-xl mb-4 font-semibold text-gray-300">Escolha o Modo de Jogo</h2>

            <!-- Botões de Seleção de Modo -->
            <div class="flex flex-col space-y-4 mb-8">
                <button id="mode1Player" class="p-4 rounded-lg bg-neon-blue/20 hover:bg-neon-blue/50 transition duration-300 neon-shadow-blue">
                    <span class="font-bold">1 JOGADOR</span> (vs. Computador)
                </button>
                <button id="mode2Players" class="p-4 rounded-lg bg-neon-pink/20 hover:bg-neon-pink/50 transition duration-300 neon-shadow-pink">
                    <span class="font-bold">2 JOGADORES</span> (Mesmo Dispositivo)
                </button>
            </div>

            <!-- Formulário de Nomes -->
            <div id="nameInputs" class="space-y-4">
                <input type="text" id="player1Input" placeholder="Seu Nome (Jogador X)" class="w-full p-3 rounded-md bg-gray-800 border-2 border-neon-blue text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-neon-blue" maxlength="15">
                <input type="text" id="player2Input" placeholder="Nome do Oponente (Jogador O)" class="w-full p-3 rounded-md bg-gray-800 border-2 border-neon-pink text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-neon-pink hidden" maxlength="15">
            </div>

            <button id="startGameButton" class="mt-8 w-full p-3 text-lg font-bold rounded-lg bg-green-600 hover:bg-green-700 transition duration-300 shadow-md hover:shadow-lg focus:outline-none disabled:opacity-50" disabled>
                INICIAR JOGO
            </button>
            <p id="error-message" class="text-red-500 mt-3 hidden">Por favor, insira o nome dos jogadores.</p>
        </div>

        <!-- TELA DO JOGO (GAME SCREEN) -->
        <div id="gameScreen" class="hidden text-center">
            <h1 class="text-2xl font-bold mb-4">Placar</h1>
            <div class="flex justify-around mb-6 text-xl">
                <div id="player1ScoreDisplay" class="p-2 rounded-lg bg-neon-blue/20 neon-shadow-blue flex-1 mx-2">
                    <span id="player1Name" class="font-bold">X</span> (X): 0
                </div>
                <div id="player2ScoreDisplay" class="p-2 rounded-lg bg-neon-pink/20 neon-shadow-pink flex-1 mx-2">
                    <span id="player2Name" class="font-bold">O</span> (O): 0
                </div>
            </div>

            <!-- Mensagem de Status/Resultado -->
            <p id="gameStatus" class="text-2xl font-bold mb-6 h-8"></p>

            <!-- Tabuleiro -->
            <div id="board" class="grid grid-cols-3 aspect-square max-w-xs mx-auto border-4 border-white/50 rounded-lg">
                <!-- Células serão preenchidas por JS -->
            </div>

            <!-- Botões de Ação -->
            <div class="mt-8 flex justify-center space-x-4">
                <button id="newGameButton" class="p-3 text-base font-semibold rounded-lg bg-yellow-600 hover:bg-yellow-700 transition duration-300">
                    Reiniciar (Mesmos Jogadores)
                </button>
                <button id="changePlayersButton" class="p-3 text-base font-semibold rounded-lg bg-red-600 hover:bg-red-700 transition duration-300">
                    Mudar Jogadores/Modo
                </button>
            </div>
        </div>

    </div>

    <script>
        // Variáveis Globais de Estado do Jogo (State Management)
        let gameMode = null; // '1p' ou '2p'
        let player1Name = 'Jogador X';
        let player2Name = 'Jogador O';
        let currentPlayer = 'X';
        let board = Array(9).fill(''); // Matriz de estado do tabuleiro: 0, 1, 2, ...
        let gameActive = false;
        let scores = { 'X': 0, 'O': 0 };

        // Elementos do DOM
        const setupScreen = document.getElementById('setupScreen');
        const gameScreen = document.getElementById('gameScreen');
        const boardElement = document.getElementById('board');
        const gameStatus = document.getElementById('gameStatus');
        const player1Input = document.getElementById('player1Input');
        const player2Input = document.getElementById('player2Input');
        const startGameButton = document.getElementById('startGameButton');
        const errorMessage = document.getElementById('error-message');

        // --- FUNÇÕES DE SETUP E UI ---

        function selectMode(mode) {
            gameMode = mode;
            const btn1p = document.getElementById('mode1Player');
            const btn2p = document.getElementById('mode2Players');
            btn1p.classList.remove('ring-4', 'ring-white/80');
            btn2p.classList.remove('ring-4', 'ring-white/80');

            if (mode === '1p') {
                player2Input.classList.add('hidden');
                player2Input.value = 'Computador';
                btn1p.classList.add('ring-4', 'ring-white/80');
                player1Input.placeholder = "Seu Nome (Você é X)";
            } else { // 2p
                player2Input.classList.remove('hidden');
                player2Input.value = '';
                btn2p.classList.add('ring-4', 'ring-white/80');
                player1Input.placeholder = "Nome do Jogador 1 (X)";
                player2Input.placeholder = "Nome do Jogador 2 (O)";
            }
            checkStartButton();
        }

        function checkStartButton() {
            const p1 = player1Input.value.trim();
            const p2 = player2Input.value.trim();
            
            if (gameMode === '1p' && p1) {
                startGameButton.disabled = false;
            } else if (gameMode === '2p' && p1 && p2) {
                startGameButton.disabled = false;
            } else {
                startGameButton.disabled = true;
            }
            errorMessage.classList.add('hidden');
        }

        function startGame() {
            player1Name = player1Input.value.trim() || 'Jogador X';
            player2Name = (gameMode === '1p') ? 'Computador' : (player2Input.value.trim() || 'Jogador O');

            if (gameMode === '2p' && (player1Name.toLowerCase() === player2Name.toLowerCase())) {
                errorMessage.textContent = "Os nomes dos jogadores não podem ser iguais!";
                errorMessage.classList.remove('hidden');
                return;
            }

            document.getElementById('player1Name').textContent = player1Name;
            document.getElementById('player2Name').textContent = player2Name;
            document.getElementById('player1ScoreDisplay').innerHTML = `<span class="font-bold">${player1Name}</span> (X): ${scores['X']}`;
            document.getElementById('player2ScoreDisplay').innerHTML = `<span class="font-bold">${player2Name}</span> (O): ${scores['O']}`;

            setupScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');

            resetBoard();
        }

        function resetBoard() {
            board.fill('');
            gameActive = true;
            currentPlayer = 'X';
            drawBoard();
            updateStatus(`É a vez de ${player1Name} (X)`);
        }

        function goToSetup() {
            setupScreen.classList.remove('hidden');
            gameScreen.classList.add('hidden');
            gameMode = null;
            scores = { 'X': 0, 'O': 0 };
            document.getElementById('mode1Player').classList.remove('ring-4', 'ring-white/80');
            document.getElementById('mode2Players').classList.remove('ring-4', 'ring-white/80');
            startGameButton.disabled = true;
            player2Input.classList.add('hidden');
        }
        
        function drawBoard() {
            boardElement.innerHTML = '';
            board.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add(
                    'flex', 'items-center', 'justify-center', 'text-4xl', 'font-extrabold',
                    'border-2', 'border-white/20', 'cursor-pointer', 'transition-all', 'duration-150', 'hover:bg-gray-800/50'
                );
                if (cell === 'X') {
                    cellElement.classList.add('cell-glow-x');
                } else if (cell === 'O') {
                    cellElement.classList.add('cell-glow-o');
                }
                cellElement.textContent = cell;
                cellElement.dataset.index = index;
                // O listener de clique humano sempre chama handleCellClick sem o flag 'isAI'.
                cellElement.addEventListener('click', () => handleCellClick(index)); 
                boardElement.appendChild(cellElement);
            });
        }

        function updateStatus(message, colorClass = 'text-white') {
            gameStatus.textContent = message;
            gameStatus.className = `text-2xl font-bold mb-6 h-8 ${colorClass === 'neon-blue' ? 'neon-text-blue' : colorClass === 'neon-pink' ? 'text-neon-pink' : 'text-white'}`;
        }

        // --- LÓGICA DO JOGO (COM MINIMAX + ALPHA-BETA OTIMIZADO) ---

        const winConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];

        /**
         * Verifica o estado atual do jogo.
         * @returns {string|null} - 'X', 'O', 'Empate' ou null.
         */
        function checkGameState(currentBoard) {
            for (let i = 0; i < winConditions.length; i++) {
                const [a, b, c] = winConditions[i];
                if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
                    return currentBoard[a]; // Retorna 'X' ou 'O'
                }
            }
            if (!currentBoard.includes('')) {
                return 'Empate';
            }
            return null;
        }

        /**
         * Lógica de Verificação do Vencedor (para exibição no tabuleiro).
         */
        function checkWinner() {
            const winner = checkGameState(board);
            if (winner && winner !== 'Empate') {
                for (let i = 0; i < winConditions.length; i++) {
                    const [a, b, c] = winConditions[i];
                    if (board[a] === winner && board[a] === board[b] && board[a] === board[c]) {
                        // Destaque a linha vencedora
                        [a, b, c].forEach(idx => {
                            // Usando um background azul mais forte para o destaque
                            boardElement.children[idx].style.cssText = `background-color: ${winner === 'X' ? '#3b82f6' : '#ec4899'}; transition: background-color 0.5s;`;
                        });
                        break;
                    }
                }
            }
            return winner;
        }


        // --- ALGORITMO MINIMAX COM PODA ALPHA-BETA (OTIMIZAÇÃO) ---

        /**
         * O Minimax com Poda Alpha-Beta é uma versão mais rápida do Minimax.
         */
        function minimax(tempBoard, depth, isMaximizing, alpha, beta) {
            const result = checkGameState(tempBoard);

            if (result !== null) {
                // Pontuação: +10 para vitória da IA, -10 para vitória do Jogador, 0 para empate.
                if (result === 'O') return 10 - depth; // Vitoria da IA (Otimiza movimentos mais rápidos)
                if (result === 'X') return -10 + depth; // Vitoria do Jogador
                return 0; // Empate
            }

            const availableSpots = tempBoard.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);
            let currentBestScore;

            if (isMaximizing) { // Vez do Computador (O) - Maximize
                currentBestScore = -Infinity;
                for (const index of availableSpots) {
                    tempBoard[index] = 'O';
                    const score = minimax(tempBoard, depth + 1, false, alpha, beta);
                    tempBoard[index] = ''; // Desfaz a jogada (backtracking)
                    
                    currentBestScore = Math.max(score, currentBestScore);
                    alpha = Math.max(alpha, currentBestScore); // Atualiza alpha
                    
                    if (beta <= alpha) { // PODA
                        break;
                    }
                }
                return currentBestScore;
            } else { // Vez do Jogador (X) - Minimize
                currentBestScore = Infinity;
                for (const index of availableSpots) {
                    tempBoard[index] = 'X';
                    const score = minimax(tempBoard, depth + 1, true, alpha, beta);
                    tempBoard[index] = ''; // Desfaz a jogada
                    
                    currentBestScore = Math.min(score, currentBestScore);
                    beta = Math.min(beta, currentBestScore); // Atualiza beta
                    
                    if (beta <= alpha) { // PODA
                        break;
                    }
                }
                return currentBestScore;
            }
        }

        /**
         * Encontra o melhor movimento chamando o Minimax.
         */
        function findBestMove() {
            let bestScore = -Infinity;
            let move = -1;

            const availableSpots = board.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);
            
            // Cria uma cópia do tabuleiro para o Minimax trabalhar
            const tempBoard = [...board]; 

            for (const index of availableSpots) {
                // Tenta a jogada
                tempBoard[index] = 'O'; 
                
                // Calcula a pontuação dessa jogada. 
                const score = minimax(tempBoard, 0, false, -Infinity, Infinity); 
                
                // Desfaz a jogada
                tempBoard[index] = ''; 

                if (score > bestScore) {
                    bestScore = score;
                    move = index;
                }
            }
            return move;
        }

        /**
         * Manipula o movimento do Computador.
         */
        function handleComputerMove() {
            // Verifica se o jogo ainda está ativo e se é a vez do computador
            if (!gameActive || currentPlayer !== 'O') return; 

            // A IA calcula e faz sua jogada
            const bestMoveIndex = findBestMove();
            
            if (bestMoveIndex !== -1) {
                // Atraso de 300ms para que o usuário veja o movimento
                // Passa 'true' para indicar que a chamada é da IA
                setTimeout(() => handleCellClick(bestMoveIndex, true), 300); 
            }
        }

        /**
         * Função principal chamada ao clicar em uma célula ou pela IA.
         * @param {number} index - Índice da célula clicada/selecionada.
         * @param {boolean} isAI - Flag para indicar se a jogada foi feita pela IA (default: false).
         */
        function handleCellClick(index, isAI = false) {
            
            // 1. Condições de Bloqueio Básico: Se o jogo não está ativo ou a célula está ocupada.
            if (!gameActive || board[index] !== '') {
                return;
            }
            
            // 2. CORREÇÃO CRÍTICA: Impede o clique humano quando é a vez da IA (no modo 1P).
            // Se for modo 1P, o jogador atual é 'O', e a chamada NÃO veio da IA (ou seja, é um clique humano),
            // a jogada é bloqueada.
            if (gameMode === '1p' && currentPlayer === 'O' && !isAI) {
                return; 
            }

            // 3. Faz o movimento
            board[index] = currentPlayer;
            drawBoard(); 

            // 4. Verifica o resultado
            const result = checkWinner();
            if (result) {
                handleResult(result);
                return;
            }

            // 5. Troca o jogador (ou chama a IA)
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            const nextPlayerName = currentPlayer === 'X' ? player1Name : player2Name;
            updateStatus(`É a vez de ${nextPlayerName} (${currentPlayer})`);

            // Se for modo 1P e for a vez do Computador, ele joga
            if (gameActive && gameMode === '1p' && currentPlayer === 'O') {
                handleComputerMove();
            }
        }

        function handleResult(result) {
            gameActive = false;
            if (result === 'Empate') {
                updateStatus('FIM DE JOGO: Deu Empate!');
            } else {
                const winnerName = (result === 'X') ? player1Name : player2Name;
                updateStatus(`VITÓRIA! ${winnerName} (${result}) ganhou!`, result === 'X' ? 'neon-blue' : 'neon-pink');
                scores[result]++;
                document.getElementById('player1ScoreDisplay').innerHTML = `<span class="font-bold">${player1Name}</span> (X): ${scores['X']}`;
                document.getElementById('player2ScoreDisplay').innerHTML = `<span class="font-bold">${player2Name}</span> (O): ${scores['O']}`;
            }
        }

        // --- INICIALIZAÇÃO E EVENT LISTENERS ---

        window.onload = function() {
            // Eventos da Tela de Configuração
            document.getElementById('mode1Player').addEventListener('click', () => selectMode('1p'));
            document.getElementById('mode2Players').addEventListener('click', () => selectMode('2p'));
            player1Input.addEventListener('input', checkStartButton);
            player2Input.addEventListener('input', checkStartButton);
            startGameButton.addEventListener('click', startGame);

            // Eventos da Tela do Jogo
            document.getElementById('newGameButton').addEventListener('click', resetBoard);
            document.getElementById('changePlayersButton').addEventListener('click', goToSetup);

            goToSetup();
        };

    </script>
</body>
</html>
